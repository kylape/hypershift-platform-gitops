---
# Job to create Certificate with dynamic hostname from cluster ingress config
# This avoids hardcoding the cluster URL in the git repo
apiVersion: v1
kind: ServiceAccount
metadata:
  name: cert-creator
  namespace: stackrox
  annotations:
    argocd.argoproj.io/sync-wave: "0"
---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: cert-creator
  annotations:
    argocd.argoproj.io/sync-wave: "0"
rules:
  - apiGroups: ["config.openshift.io"]
    resources: ["ingresses"]
    verbs: ["get"]
  - apiGroups: ["cert-manager.io"]
    resources: ["certificates"]
    verbs: ["get", "create", "update", "patch"]
  - apiGroups: ["route.openshift.io"]
    resources: ["routes"]
    verbs: ["get", "patch"]
---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: cert-creator
  annotations:
    argocd.argoproj.io/sync-wave: "0"
subjects:
  - kind: ServiceAccount
    name: cert-creator
    namespace: stackrox
roleRef:
  kind: ClusterRole
  name: cert-creator
  apiGroup: rbac.authorization.k8s.io
---
apiVersion: batch/v1
kind: Job
metadata:
  name: create-central-certificate
  namespace: stackrox
  annotations:
    argocd.argoproj.io/sync-wave: "0"
    argocd.argoproj.io/hook: Sync
    argocd.argoproj.io/hook-delete-policy: HookSucceeded
spec:
  ttlSecondsAfterFinished: 300
  backoffLimit: 1
  template:
    spec:
      serviceAccountName: cert-creator
      restartPolicy: Never
      containers:
        - name: create-cert
          image: registry.redhat.io/openshift4/ose-cli:latest
          command:
            - /bin/bash
            - -c
            - |
              set -e

              # Cleanup function to restore route redirect on exit
              cleanup() {
                echo "Restoring Central route redirect policy..."
                oc patch route central -n stackrox --type=merge \
                  -p '{"spec":{"tls":{"insecureEdgeTerminationPolicy":"Redirect"}}}' || true
              }
              trap cleanup EXIT

              # Get the cluster's ingress domain
              INGRESS_DOMAIN=$(oc get ingress.config.openshift.io cluster -o jsonpath='{.spec.domain}')
              CENTRAL_HOSTNAME="central-stackrox.${INGRESS_DOMAIN}"

              echo "Target hostname: ${CENTRAL_HOSTNAME}"

              # Check if certificate already exists and is valid
              EXISTING=$(oc get certificate central-tls -n stackrox -o jsonpath='{.spec.dnsNames[0]}' 2>/dev/null || echo "")
              READY=$(oc get certificate central-tls -n stackrox -o jsonpath='{.status.conditions[?(@.type=="Ready")].status}' 2>/dev/null || echo "")

              if [ "${EXISTING}" = "${CENTRAL_HOSTNAME}" ] && [ "${READY}" = "True" ]; then
                echo "Certificate already exists and is ready, skipping"
                trap - EXIT  # Don't run cleanup since we didn't change anything
                exit 0
              fi

              # Temporarily disable HTTP redirect on Central route
              # This allows the HTTP-01 ACME challenge to succeed
              echo "Disabling Central route HTTP redirect for ACME challenge..."
              oc patch route central -n stackrox --type=merge \
                -p '{"spec":{"tls":{"insecureEdgeTerminationPolicy":"None"}}}'

              # Create or update the Certificate
              echo "Creating Certificate resource..."
              cat <<EOF | oc apply -f -
              apiVersion: cert-manager.io/v1
              kind: Certificate
              metadata:
                name: central-tls
                namespace: stackrox
              spec:
                secretName: central-default-tls-cert
                issuerRef:
                  name: letsencrypt-prod
                  kind: ClusterIssuer
                dnsNames:
                  - ${CENTRAL_HOSTNAME}
                duration: 2160h
                renewBefore: 360h
              EOF

              # Wait for certificate to be ready (up to 5 minutes)
              echo "Waiting for certificate to be issued..."
              for i in $(seq 1 60); do
                READY=$(oc get certificate central-tls -n stackrox -o jsonpath='{.status.conditions[?(@.type=="Ready")].status}' 2>/dev/null || echo "")
                if [ "${READY}" = "True" ]; then
                  echo "Certificate issued successfully!"
                  exit 0
                fi

                # Check for failure
                REASON=$(oc get certificate central-tls -n stackrox -o jsonpath='{.status.conditions[?(@.type=="Ready")].reason}' 2>/dev/null || echo "")
                if [ "${REASON}" = "Failed" ]; then
                  echo "Certificate issuance failed!"
                  oc get certificate central-tls -n stackrox -o jsonpath='{.status.conditions[?(@.type=="Ready")].message}'
                  exit 1
                fi

                echo "  Waiting... (${i}/60) - Status: ${REASON:-Pending}"
                sleep 5
              done

              echo "Timeout waiting for certificate"
              exit 1
